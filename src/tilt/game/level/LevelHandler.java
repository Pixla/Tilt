package tilt.game.level;

import java.io.InputStream;
import java.util.Scanner;

import org.newdawn.slick.util.ResourceLoader;

import tilt.game.level.components.Tile;
import tilt.game.level.components.tiles.BoostE;
import tilt.game.level.components.tiles.BoostN;
import tilt.game.level.components.tiles.BoostS;
import tilt.game.level.components.tiles.BoostW;
import tilt.game.level.components.tiles.Floor;
import tilt.game.level.components.tiles.Gate5;
import tilt.game.level.components.tiles.Goal;
import tilt.game.level.components.tiles.Hole;
import tilt.game.level.components.tiles.InverseGate5;
import tilt.game.level.components.tiles.Spawn;
import tilt.game.level.components.tiles.Wall;

/**
 * This class is in charge of loading and parsing level files to be used by the
 * main class
 * 
 * @author Sam Luc
 * @group Joseph Guinto, Jan Martin
 */
public class LevelHandler {

	/**
	 * Loads a level file at specified path into an object. Returns the level
	 * object.
	 * 
	 * @param ref
	 *            Path of the level file to be loaded
	 * @return level object generated by file
	 */
	public static Level load(String ref) {
		try {
			InputStream stream = ResourceLoader.getResourceAsStream(ref);
			Scanner scan = new Scanner(stream);

			int[][] map = new int[0][0];

			int width = -1;
			int height = -1;
			int x = 0;
			int y = 0;

			// Set the level title
			String name = scan.nextLine();
			while (scan.hasNextInt()) {
				// First two numbers are map dimensions
				if (width == -1) {
					width = scan.nextInt();
				} else if (height == -1) {
					height = scan.nextInt();
				}
				// If the map array has not been created, and width and height
				// have been specified, create a new array
				if (map.length < 1 || map[0].length < 1) {
					if (width > -1 && height > -1) {
						map = new int[height][width];
					}
				} else {
					// The rest of the number correspond to tiles
					map[y][x] = scan.nextInt();
					// Next column
					x++;
					// If you have reached the end of a column...
					if (x >= width) {
						// Return to first column
						x = 0;
						// Next row
						y++;
					}
					// If you have reached the end of the rows
					if (y >= height) {
						// You're done!
						break;
					}
				}
			}

			scan.close();

			// Use the helper function to turn the array into a map
			Level newLevel = load(map);
			// Set the level name from the name found in the file
			newLevel.name = name;

			return newLevel;
		} catch (Exception e) {
			// If there are any problems whatsoever, just print an error and
			// return nothing, the null level file should be handled elsewhere
			// and skipped
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Takes a 2d array of integers, converts them to tiles and adds it to a
	 * Level object. Never called externally as it does not handle level names,
	 * a "helper" function.
	 * 
	 * @param map
	 *            2d array of integers
	 * @return corresponding level
	 */
	private static Level load(int[][] map) {
		// Create the level in memory
		Level newLevel = new Level();
		// Create the level tile array based on the size of the integer array
		newLevel.map = new Tile[map.length][map[0].length];

		// Go through each integer in array and convert it to the corresponding
		// tile object
		/*
		 * 0 = Hole 1 = Floor 2 = Wall 3 = Spawn 4 = Goal 5-8 = Boosters (N, E,
		 * S, W) 9 = Gate (5 seconds) 10 = IGate (5 seconds)
		 */
		for (int y = 0; y < map.length; y++) {
			for (int x = 0; x < map[0].length; x++) {
				Tile newTile = null;
				switch (map[y][x]) {
				case 0:
					newTile = new Hole();
					break;
				case 1:
					newTile = new Floor();
					break;
				case 2:
					newTile = new Wall();
					break;
				case 3:
					newTile = new Spawn();
					break;
				case 4:
					newTile = new Goal();
					break;
				case 5:
					newTile = new BoostN();
					break;
				case 6:
					newTile = new BoostE();
					break;
				case 7:
					newTile = new BoostS();
					break;
				case 8:
					newTile = new BoostW();
					break;
				case 9:
					newTile = new Gate5();
					break;
				case 10:
					newTile = new InverseGate5();
					break;
				default: // Should never be reached, but just in case
					newTile = new Floor();
					break;
				}
				// Set the tile at coordinates to be the tile we just made
				newLevel.map[y][x] = newTile;
			}
		}

		// Return the level
		return newLevel;
	}

}
